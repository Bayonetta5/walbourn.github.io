---
layout: post
title: What's in a version number?
date: 2010-02-24 11:39
author: walbourn
comments: true
categories: [directx, Uncategorized]
---
<p>There are many version numbers in Windows, and many different ways to obtain and use them. The plethora of ways to get versioning information, and the many different kinds of components involved, has typically resulted in lots of rope for developers to hang themselves. These messes tend to explode when a new Service Pack comes out or with a new release of the Windows OS. This is often a shame because otherwise the programs work perfectly well on the new version of Windows as long as you lie to them about the OS version number. In fact there's a lot of work put into identifying failing applications and putting in explicit code to lie about the OS version number for each of them, but this manual can't be done for every piece of software on the planet. There's been some <a title="recent work" href="http://msdn.microsoft.com/en-us/library/dd371711(VS.85).aspx">recent work</a> to try to automate this, but it too relies on developers to "do the right thing" so ultimately it isn't a problem that can be completely fixed here in Redmond.</p>
<p>The recommendation has long been to not use version numbers. For features that might or might not be available, there is usually a trivial way to handle it that works successfully without ever relying on OS version information. Using LoadLibrary() and GetProcAddress() is perhaps the most well-known way to test for&nbsp;an entry-point that you want to use that might or might not be available. Clever use of /DELAYLOAD can also achieve the same effect, although it's <a title="not recommended" href="http://blogs.msdn.com/larryosterman/archive/2009/03/06/delay-load-is-not-a-good-way-to-check-for-functionality.aspx">not recommended</a>.&nbsp;Creating a COM factory object and handling failure is also very common. The main point here is that any time you think you need an OS version check in your code: stop and find an alternative. This problem is extremely pervasive, and why we continue to drive this message home through the <a title="Games for Windows TR 2.5" href="http://msdn.microsoft.com/en-us/library/ee417691(VS.85).aspx">Games for Windows TR 2.5</a> advocating the use of the HighVersionLie test in <a title="Application Verifier" href="http://blogs.msdn.com/b/wit/archive/2008/11/04/white-lies-using-appverifier-to-test-os-versioning.aspx">Application Verifier</a> to make sure this problem isn't lurking in your game.</p>
<p>With that said, there is one extremely common and reasonable use for an OS version check:&nbsp;your installer&nbsp;sets a 'minimum bar' of supported OSes.&nbsp;I like to think of them as "your OS must be this high to ride this ride" tests. The critically important aspect of these version checks is that they, when properly written, are unbounded on high-end of the range. Microsoft developers go through a lot of pain and difficulty to ensure that future versions of the OS continue to support the vast majority of existing applications so assuming the worst of a future OS is generally not worth the cost and hassle of blocking 'forward'. It is, however, completely reasonable to set a point below which you don't want to support legacy versions of Windows. This typically makes for cleaner code, and means you don't have to rely as heavily on the LoadLibrary()/GetProcAddress() solution on every Win32 call introduced after Windows 1.0.</p>
<p>So your sold on the idea of having exactly one OS version check in your entire application and it's limited to the installer. Great, what is the right way to do it? Well, as it turns out there are dozens of incorrect ways people have done this ranging from wonky expressions to registry key shenanigans. An extremely robust way to do it is to use the following C++ code example for <strong>DirectX 9.0c games</strong>:</p>
<p><code>HMODULE hMod = LoadLibrary( TEXT("kernel32") );<br />assert( hMod != 0); // Win32 programs have to have this module loaded&hellip;</code></p>
<p><code>OSVERSIONINFOEX osv;<br />memset( &amp;osv, 0, sizeof(osv) );<br />osv.dwOSVersionInfoSize = sizeof(osv);</code></p>
<p><code>osv.dwMajorVersion = 5;&nbsp; // Windows XP Service Pack 3 or later<br />osv.dwMinorVersion = 1;<br />osv.wServicePackMajor = 3;<br />osv.wServicePackMinor = 0;</code></p>
<p><code>DWORDLONG mask = 0;</code></p>
<p><code>typedef ULONGLONG ( WINAPI* fpSetMask )( ULONGLONG, DWORD, BYTE );<br />fpSetMask fpVerSetConditionMask = (fpSetMask)GetProcAddress( hMod, "VerSetConditionMask" );</code></p>
<p><code>if (fpVerSetConditionMask != 0) {<br />&nbsp;mask = fpVerSetConditionMask( mask, VER_MAJORVERSION, VER_GREATER_EQUAL );<br />&nbsp;mask = fpVerSetConditionMask( mask, VER_MINORVERSION, VER_GREATER_EQUAL );<br />&nbsp;mask = fpVerSetConditionMask( mask, VER_SERVICEPACKMAJOR, VER_GREATER_EQUAL );<br />&nbsp;mask = fpVerSetConditionMask( mask, VER_SERVICEPACKMINOR, VER_GREATER_EQUAL );<br />}</code></p>
<p><code>typedef BOOL ( WINAPI* fpVerify )( LPOSVERSIONINFOEX, DWORD, DWORDLONG );<br />fpVerify fpVerifyVersionInfo = (fpVerify)GetProcAddress( hMod, "VerifyVersionInfoW" ); // Assumes UNICODE</code></p>
<p><code>if ( !fpVerifyVersionInfo || !fpVerifyVersionInfo( &amp;osv,<br />&nbsp;&nbsp;&nbsp; VER_MAJORVERSION | VER_MINORVERSION | VER_SERVICEPACKMAJOR | VER_SERVICEPACKMINOR, mask ) ) {<br />&nbsp;error("This program requires Windows XP Service Pack&nbsp;3 or later\n");<br />}</code></p>
<p><code>osv.dwMajorVersion = 5;&nbsp; // Windows Server 2003 RTM<br />osv.dwMinorVersion = 2;<br />osv.wServicePackMajor = 0;</code></p>
<p><code>mask = 0;</code></p>
<p><code>if (fpVerSetConditionMask != 0) {<br />&nbsp;mask = fpVerSetConditionMask( mask, VER_MAJORVERSION, VER_EQUAL );<br />&nbsp;mask = fpVerSetConditionMask( mask, VER_MINORVERSION, VER_EQUAL );<br />&nbsp;mask = fpVerSetConditionMask( mask, VER_SERVICEPACKMAJOR, VER_EQUAL );<br />}</code></p>
<p><code>if ( fpVerifyVersionInfo( &amp;osv,<br />&nbsp;&nbsp;&nbsp; VER_MAJORVERSION | VER_MINORVERSION | VER_SERVICEPACKMAJOR, mask ) ) {<br />&nbsp;error("This program requires Windows Server 2003 SP1 or later\n");<br />}</code></p>
<p>At this point we know the OS already includes the DirectX 9.0c Runtime or later. We know that Direct3D 9, DirectSound8, DirectInput8, etc are all present. We only need to use the DirectX SDK DirectSetup REDIST if our application makes use of optional side-by-side components like D3DX, XAUDIO2, XINPUT, XACT, etc. See <a title="DirectX Installation for Game Developers" href="http://msdn.microsoft.com/en-us/library/ee416805(VS.85).aspx">DirectX Installation for Game Developers</a> for details on how to configure a minimal package for this purpose.</p>
<p>NOTE: The one thing this doesn't capture is that some seldom used DirectX components were removed from the OS starting with Windows Vista. As long as your application doesn't make use of <a title="Direct3D Retained Mode" href="http://support.microsoft.com/kb/969150">Direct3D Retained Mode</a>, <a title="DirectPlay Voice" href="http://support.microsoft.com/kb/970978">DirectPlay Voice</a>, or <a title="Visual Basic 6.0 DirectX interfaces" href="http://support.microsoft.com/kb/971028">Visual Basic 6.0 DirectX interfaces</a> this should not be an issue.</p>
<p>For Direct3D 9 Windows games, it is worth going one step further...</p>
<p><code>osv.dwMajorVersion = 6;&nbsp; // Windows Vista / Server 2008 RTM<br />osv.dwMinorVersion = 0;<br />osv.wServicePackMajor = 0;</code></p>
<p><code>// Reuse mask from last test (equals test)</code></p>
<p><code>&nbsp;if ( fpVerifyVersionInfo( &amp;osv,<br />&nbsp;&nbsp;&nbsp; VER_MAJORVERSION | VER_MINORVERSION | VER_SERVICEPACKMAJOR, mask ) ) {<br />&nbsp;error(&ldquo;This program requires Windows Vista SP2, Windows Server 2008 SP2, or later\n");<br />}</code></p>
<p><code>osv.dwMajorVersion = 6;&nbsp; // Windows Vista / Server 2008 SP1<br />osv.dwMinorVersion = 0;<br />osv.wServicePackMajor = 1;</code></p>
<p><code>// Reuse mask from last test (equals test)</code></p>
<p><code>&nbsp;if ( fpVerifyVersionInfo( &amp;osv,<br />&nbsp;&nbsp;&nbsp; VER_MAJORVERSION | VER_MINORVERSION | VER_SERVICEPACKMAJOR, mask ) ) {<br />&nbsp;error(&ldquo;This program requires Windows Vista SP2, Windows Server 2008 SP2, or later\n");<br />}</code></p>
<p>At this point we have excluded Windows Vista / Server 2008 RTM. This is useful because it ensures you already have the <a title="KB940105" href="http://support.microsoft.com/default.aspx/kb/940105">KB 940105</a> VA space fix, as well as the Direct3D 10.1 Runtime.</p>
<p><strong>Windows XP:</strong> The sample code has been modified from the original posting to use Windows XP SP3 as the baseline instead of Windows XP SP2 as this was the last version of Windows XP supported with security updates.</p>
<p><strong>Windows Vista: </strong>The sample code has been modified from the original posting to exclude both Windows Vista RTM and Windows Vista SP1 as this is the last version of Windows Vista supported with security updates.</p>
<p><strong>DirectX 11 Games:</strong> The check above assumes you require DirectX 9.0c as your baseline. For newer games that use DirectX 11.0 as their baseline, the check should be &gt;= Windows Vista SP2 if you use the techniques in <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ee416644.aspx">Direct3D 11 Deployment for Game Developers</a>&nbsp;to handle detection of KB971644, or use &gt;= Windows 7 for simplicity.</p>
<p><strong>Windows 7:</strong> Windows 7 Service Pack 1 is mandatory at this point in the Windows 7 lifecycle, so excluding support for Windows 7 RTM is strongly recommended. VS 2013 and VS 2015 do not support targeting Windows 7 RTM and the C++ REDIST requires Windows 7 Service Pack 1.</p>
<p><strong>Windows 8</strong>: This check works as designed on Windows 8 for Win32 desktop applications. Windows 8 is officially version "6.2"</p>
<p><strong>Windows 8.1:</strong> This check works as designed on Windows 8.1 for Win32 desktop applications. Windows 8.1 is officially version "6.3". Note that the <code>GetVersion(Ex)</code> API has been actively deprecated on Windows 8.1 and by default will still return "6.2". See this <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/dn302074.aspx">link</a> and this <a href="http://blogs.msdn.com/b/chuckw/archive/2013/09/10/manifest-madness.aspx">blog post</a> for more details.</p>
<p><strong>Windows 10:</strong> This check works as designed on Windows 10 for Win32 desktop applications. Windows 10 is officially version "10.0" (it was "6.4" in the original Windows 10 Technical Preview build 9841). Note that the <code>GetVersion(Ex)</code> API has been actively deprecated and by default will still return "6.2" or "6.3". With Windows 10 <code>VerifyVersionInfo</code> is also subject to the same manifest-based behavior as <code>GetVersion(Ex)--</code><code>IsWindows8_1OrGreater</code> and <code>IsWindows10OrGreater</code> will both return FALSE on Windows 10 without a proper embedded manifest in the EXE.&nbsp;See this&nbsp;<a href="http://blogs.msdn.com/b/chuckw/archive/2013/09/10/manifest-madness.aspx">blog post</a>&nbsp;for more details.</p>
<p><strong>universal Windows apps in Windows 10:</strong> There is a <a href="https://msdn.microsoft.com/en-us/library/windows/apps/windows.system.profile.analyticsinfo.versioninfo">new WinRT API</a> you should use for telemetry in the <code>Windows.System.Profile</code> namespace.</p>
<p><strong>Windows 8.1 SDK / VS 2013: </strong>There is a new header <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/dn302074.aspx">VersionHelpers.h</a> that provides similar 'you must be this high to ride this ride' checks as well. These helpers just use the same <code>VerifyVersionInfo</code> function I do above, but do so with implicit rather than explicit linking. That means the code won't work on Windows 9x/Windows ME like the code I wrote here would, but that's well below the supported OS level for either the Windows 8.1 SDK or the VS 2013 compiler anyhow.</p>
<p><strong>Diagnostic Logs:</strong> If you are just trying to obtain a version number for a diagnostic log output, the best thing to do is just call <code>GetVersion(Ex)</code> and add the <a href="http://blogs.msdn.com/b/chuckw/archive/2013/09/10/manifest-madness.aspx">compatibly manifest </a>to your EXE. If you are in a scenario where you can't add the manifest, you can make use of WMI with the <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa394239.aspx">Win32_OperatingSystem</a> class</p>
<p><a href="https://msdnshared.blob.core.windows.net/media/MSDNBlogsFS/prod.evol.blogs.msdn.com/CommunityServer.Components.PostAttachments/00/09/96/88/46/oscheck.zip" original-url="http://blogs.msdn.com/cfs-file.ashx/__key/communityserver-components-postattachments/00-09-96-88-46/oscheck.zip">oscheck.zip</a></p>
