---
layout: post
title: Known Issues in XNAMath v2.03
date: 2011-01-20 10:57
author: walbourn
comments: true
categories: [Uncategorized, xnamath]
---
<p>Some users of <a title="XNA Math Library Programmers Guide (MSDN)" href="http://msdn.microsoft.com/en-us/library/ee415571.aspx">XNAMath</a> have reported a range problem with the <strong>XMVectorFloor</strong> and <strong>XMVectorCeiling</strong> functions with the SSE implementation (i.e. whenever the values are greater than INT_MAX). These fixes will be included in a future release of XNAMath, but since XNAMath is an all-header implementation it can also be fixed directly by affected developers in the <code>xnamathvector.inl</code> file.</p>
<p>Here are the corrected versions:</p>
<pre class="scroll"><code class="cplusplus">XMFINLINE XMVECTOR XMVectorFloor<br /> (<br /> FXMVECTOR V<br /> )<br /> {<br /> #if defined(_XM_NO_INTRINSICS_)<br /> <br /> XMVECTOR vResult = {<br /> floorf(V.vector4_f32[0]),<br /> floorf(V.vector4_f32[1]),<br /> floorf(V.vector4_f32[2]),<br /> floorf(V.vector4_f32[3])<br /> };<br /> return vResult;<br /> <br /> #elif defined(_XM_SSE_INTRINSICS_)<br /> // To handle NAN, INF and numbers greater than 8388608, use masking<br /> // Get the abs value<br /> __m128i vTest = _mm_and_si128(reinterpret_cast&lt;const __m128i *&gt;(&amp;V)[0],g_XMAbsMask);<br /> // Test for greater than 8388608 (All floats with NO fractionals, NAN and INF<br /> vTest = _mm_cmplt_epi32(vTest,g_XMNoFraction);<br /> // Convert to int and back to float for rounding<br /> XMVECTOR vResult = _mm_sub_ps(V,g_XMOneHalfMinusEpsilon);<br /> __m128i vInt = _mm_cvtps_epi32(vResult);<br /> // Convert back to floats<br /> vResult = _mm_cvtepi32_ps(vInt);<br /> // All numbers less than 8388608 will use the round to int<br /> vResult = _mm_and_ps(vResult,reinterpret_cast&lt;const XMVECTOR *&gt;(&amp;vTest)[0]);<br /> // All others, use the ORIGINAL value<br /> vTest = _mm_andnot_si128(vTest,reinterpret_cast&lt;const __m128i *&gt;(&amp;V)[0]);<br /> vResult = _mm_or_ps(vResult,reinterpret_cast&lt;const XMVECTOR *&gt;(&amp;vTest)[0]);<br /> return vResult;<br /> #else // _XM_VMX128_INTRINSICS_<br /> #endif // _XM_VMX128_INTRINSICS_<br /> }<br /> <br /> //------------------------------------------------------------------------------<br /> <br /> XMFINLINE XMVECTOR XMVectorCeiling<br /> (<br /> FXMVECTOR V<br /> )<br /> {<br /> #if defined(_XM_NO_INTRINSICS_)<br /> XMVECTOR vResult = {<br /> ceilf(V.vector4_f32[0]),<br /> ceilf(V.vector4_f32[1]),<br /> ceilf(V.vector4_f32[2]),<br /> ceilf(V.vector4_f32[3])<br /> };<br /> return vResult;<br /> <br /> #elif defined(_XM_SSE_INTRINSICS_)<br /> // To handle NAN, INF and numbers greater than 8388608, use masking<br /> // Get the abs value<br /> __m128i vTest = _mm_and_si128(reinterpret_cast&lt;const __m128i *&gt;(&amp;V)[0],g_XMAbsMask);<br /> // Test for greater than 8388608 (All floats with NO fractionals, NAN and INF<br /> vTest = _mm_cmplt_epi32(vTest,g_XMNoFraction);<br /> // Convert to int and back to float for rounding<br /> XMVECTOR vResult = _mm_add_ps(V,g_XMOneHalfMinusEpsilon);<br /> __m128i vInt = _mm_cvtps_epi32(vResult);<br /> // Convert back to floats<br /> vResult = _mm_cvtepi32_ps(vInt);<br /> // All numbers less than 8388608 will use the round to int<br /> vResult = _mm_and_ps(vResult,reinterpret_cast&lt;const XMVECTOR *&gt;(&amp;vTest)[0]);<br /> // All others, use the ORIGINAL value<br /> vTest = _mm_andnot_si128(vTest,reinterpret_cast&lt;const __m128i *&gt;(&amp;V)[0]);<br /> vResult = _mm_or_ps(vResult,reinterpret_cast&lt;const XMVECTOR *&gt;(&amp;vTest)[0]);<br /> return vResult;<br /> #else // _XM_VMX128_INTRINSICS_<br /> #endif // _XM_VMX128_INTRINSICS_<br /> }</code></pre>
<p><em>&nbsp;Note that this is the same technique used by <strong>XMVectorRound</strong> to get around the same range issue in the SSE2 float&lt;-&gt;integer conversion mechanism.</em></p>
<p><strong>Note: </strong>This issue has been fixed for <a href="http://blogs.msdn.com/b/chuckw/archive/2011/02/23/xna-math-version-2-04.aspx">XNAMath v2.04</a> and <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/hh437833.aspx">DirectXMath</a>.</p>
